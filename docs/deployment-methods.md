---
layout: news_item
title: "dbic cookbook"
date: "2013-09-06 02:12:52 +0200"
description: "DBIx::Class cookbook translate"
author: 舌尖上的牛氓
version: 1.0.0
categories: [release]
---

# 什么是 DBIx::Class

`DBIx::Class` 是一个perl5的面向对象的数据库 `api` ,相比传统的 `DBI`, `DBIx::Class` 提供了更为强大的功能和更灵活,更好扩展的特性,可能有些人觉得`oop`的perl编程相比原来的传统`DBI`速度上并 没有什么优势,但是实际上数据库操作的瓶颈真正在于数据库的优化,表的优化,`SQL`的优化, 而应用程序的影响在当今的条件下已经可以忽略不计.

# 概要

`DBIx::Class`可以分为几大部分:  `Schema` , `Result` , `ResultSource` , `Storage` , `ResultSet`

`schema-DBIx::Class::Schema` 这个类主要用来导入一个库的 schema. 

`Result-DBIx::Class::Result` 主要设置数据库表的属性,一般是一个表一个 pm文件,类似配置文件的功能. 

`ResultSet-DBIx::Class::ResultSet` sql查询的类,可扩展 

`Storage-DBIx::Class::Storage` DBIx 的 storage.



# DBIx begin

下面就开始 DBIx 的操作了 以建立 artist,cd,track 3个表为例,要使用 DBIx ,我们首先配置每张表的 schema ,一个表的属性 就是一个 pm 
包,以这个三个表为例.
 



## config schema

配置好 schema `MyDatabase::Main::Result::Artist`
(\#ps这里一般都不手写了，可以在db建好了，然后用脚本倒出来，还支持moose的哦)

    package MyDatabase::Main::Result::Artist;

    use warnings;
    use strict;
    use base qw/DBIx::Class::Core/;

    __PACKAGE__->table('artist'); 
    __PACKAGE__->add_columns(qw/ artistid name /); #columns config

    __PACKAGE__->set_primary_key('artistid');    # set pk
    __PACKAGE__->has_many('cds' => 'MyDatabase::Main::Result::Cd'); #set relation

    1;

    package MyDatabase::Main::Result::Cd;
    use warnings;
    use strict;

    use base qw/DBIx::Class::Core/;
    __PACKAGE__->table('cd');
    __PACKAGE__->add_columns(qw/ cdid artist title/);

    __PACKAGE__->set_primary_key('cdid');
    __PACKAGE__->belongs_to('artist' => 'MyDatabase::Main::Result::Artist');

    __PACKAGE__->has_many('tracks' => 'MyDatabase::Main::Result::Track');
    1;

    package MyDatabase::Main::Result::Track;

    use warnings;
    use strict;
    use base qw/DBIx::Class::Core/;

    __PACKAGE__->table('track');
    __PACKAGE__->add_columns(qw/ trackid cd title/);
    __PACKAGE__->set_primary_key('trackid');

    __PACKAGE__->belongs_to('cd' => 'MyDatabase::Main::Result::Cd');

    1;

然后我们需要导入这些表的 schema 的 namespace : 
Main.pm 然后开始创建表:

    package MyDatabase::Main;
    use base qw/DBIx::Class::Schema/;

    __PACKAGE__->load_namespaces;
    1;

    CREATE TABLE artist (
      artistid INTEGER PRIMARY KEY,
      name TEXT NOT NULL 
    );

    CREATE TABLE cd (
      cdid INTEGER PRIMARY KEY,
      artist INTEGER NOT NULL REFERENCES artist(artistid),
      title TEXT NOT NULL

    );
    CREATE TABLE track (
      trackid INTEGER PRIMARY KEY,
      cd INTEGER NOT NULL REFERENCES cd(cdid),
      title TEXT NOT NULL

    );
    

最后我们需要往表里插入数据,这里只作为测试,就不说明代码了:

    #!/usr/bin/env perl
    use strict;

    use warnings;
    use MyDatabase::Main;
    my $database = "dbix";

    my $hostname = 'localhost';
    my $port = 3306;

    my $dsn = "DBI:mysql:database=$database;host=$hostname;port=$port";
    my $user = 'root';
    my $pass = 'root';
    my $schema = MyDatabase::Main->connect( $dsn );

    #  here's some of the sql that is going to be generated by the schema
    #  INSERT INTO artist VALUES (NULL,'Michael Jackson');
    #  INSERT INTO artist VALUES (NULL,'Eminem');
    my @artists = (['Michael Jackson'], ['Eminem']);

    $schema->populate('Artist', [
        [qw/name/],
        @artists,
    ]);
    my %albums = (
        'Thriller' => 'Michael Jackson',
        'Bad' => 'Michael Jackson',
        'The Marshall Mathers LP' => 'Eminem',
    );

    my @cds;
    foreach my $lp (keys %albums) {
        my $artist = $schema->resultset('Artist')->find({
            name => $albums{$lp}
        });
        push @cds, [$lp, $artist->id];
    }
    $schema->populate('Cd', [
        [qw/title artist/],
        @cds,
    ]);
    my %tracks = (
        'Beat It'         => 'Thriller',
        'Billie Jean'     => 'Thriller',
        'Dirty Diana'     => 'Bad',
        'Smooth Criminal' => 'Bad',
        'Leave Me Alone'  => 'Bad',
        'Stan'            => 'The Marshall Mathers LP',
        'The Way I Am'    => 'The Marshall Mathers LP',
    );
    my @tracks;

    foreach my $track (keys %tracks) {
        my $cd = $schema->resultset('Cd')->find({
            title => $tracks{$track},
        });
        push @tracks, [$cd->id, $track];
    }
    $schema->populate('Track',[
        [qw/cd title/],
        @tracks,
    ]);
    

ok,现在有了可以操作的数据库和表了

## connect database

接下来就是连接数据库,不同的数据库连接方式大同小异,不同的只是 dbi\_dsn 部分,`\%dbi_params` 可以设置一些属性例如
{ AutoCommit => 1,...}

    #DBI:mysql:database=$database;host=$hostname;port=$port
    my $schema = MyApp::Schema->connect($dbi_dsn, $user, $pass, \%dbi_params);

    #pgsql
    my $schema = DB::Schema->connection('dbi:Pg:dbname=test');

    #DBI:mysql:database=$database;host=$hostname;port=$port



# SQL

sql 是 dbi 最常要做的,`DBIx::Class`采用了很多关键字来实现 sql ,所有的 sql 操作都通过这些 关键字来实现,下面是一些例子:

    my $johns_rs = $schema->resultset('Artist')->search(
      # Build your WHERE using an SQL::Abstract structure:
      { name => { like => 'John%' } }
    );
    # Execute a joined query to get the cds.
    my @all_john_cds = $johns_rs->search_related('cds')->all;

     #real SQL:
     # select * from 
     # artist 
     # where  name like 'John%'
    



## keyword ( not, like,!=,=,>,<,or)

DBIx 的 sql 查询分为2部分,首先导入表对象,也就是

    $schema->resultset('Cd')#Cd对应之前设置的pm包的名字,注意不是表名,如果填表名
    #这里会抛出一个异常
    

然后就是 search 了, search 就类似`DBI`里面的`prepare`

    $schema->resultset('Cd')->search(
        {}, #这里配置where条件里的sql语句
        {}  #这里配置h后面的修饰的语句和select部分,
    )

看下面的例子:

    sub test_sql_select_where_basic{
      my $rs = $schema->resultset('Cd')->search(
        {
            'cdid'  => [1,3],
            'title' => 'Bad',
            'title' => {'like','%Bad%'},
            'cdid'  => 3,
            'artist'=> {'between'=>[1,3]},
            'cdid'  => { '>'=>2},
        },
      );
      $rs->next;
    }

上面的例子涵盖了not,like等的用法,基本的原则就是在一个{}里面,定义where条件,对于多个值的区域采取\[\]引用, 是所有条件的运算符紧在在字段后面的hash引用里面. 对应输出的SQL：

       SELECT me.cdid, me.artist, me.title
       FROM cd me
       WHERE
       (
           (
               ( artist BETWEEN '1' AND '3' )
               AND
               cdid > '2'
               AND
               title LIKE '%Bad%'
           )
       )
    



## group by

groupby 的例子：

     my $rs = $schema->resultset('Cd')->search(
       {
       },
       {
         group_by  => 'cdid',
       }
     );
     $rs->next;
    

## order by

oderby 例子：

    my $rs = $schema->resultset('Cd')->search(
      {
          'cdid'  => [1,3],
          'title' => 'Bad',
          'title' => {'like','%Bad%'},
          'cdid'  => 3,
          'artist'=> {'between'=>[1,3]},
          'cdid'  => { '>'=>2},
          'cdid'  => {'in' => [1,3]}
      },
      {
        order_by  => 'cdid',
      }
    );

    $rs->next;

     __DATA__
     SQL:
        SELECT me.cdid, me.artist, me.title FROM cd me
        WHERE ( ( ( artist BETWEEN '1' AND '3' ) AND cdid > '2' AND title LIKE '%Bad%' ) )
        ORDER BY cdid
    

## as,alias

有的时候 sql 需要定义别名,`DBIx`的做法是:

    $rs = $schema->resultset('Cd')->search(
      {},
      {
        'select' => ['title',{LENGTH => 'cdid'}],
        'as' => ['tit','len_cd'],
      }
    );

    my $cd = $rs->next;
    my $name_length = $cd->get_column('tit');

    print "name lenth is $name_length\n";

`select` : 确定选定的列表 

`as`     : 后面的列表为对应的select的列表里面字段的别名 

`LENGTH` : 数据库的函数,通常我们要获取别名的数据,是通过get\_column来获取,但是也可以实现在schema文件里面配置好.

## sum,average,man,min

使用数据库的函数

    $rs = $schema->resultset('Cd')->search(
      {},
      {
        'select' => [
          {'max' => 'title'},
          {'sum' => 'cdid'},
        ],
        'as' => ['max_title','sum_cd'],
        'group_by' => 'cdid',
      }
    );
    my $cd = $rs->next;

    my $name_length = $cd->get_column('max_title');
    my $sum_title = $cd->get_column('sum_cd');

    #equal SQL:
    #SELECT MAX( title ), SUM( cdid ) FROM cd me GROUP BY cdid

    

另外一种方法就是 oo 风格

    my $rs = $schema->resultset('Cd')->search(
        undef,
        {
            columns =>  ['cdid','title'],
        }
    );
    my $count = $rs->count;

## sub query

sql 子查询经常会用到,`DBIx`同样可以实现,看下面的例子:

    my $rs = $schema->resultset('Cd')->search(
        {
            artist => [qw/5 6/],
        }
    );#sub query

    my $ar_rs = $schema->resultset('Artist')->search(
        'artistid' => {
                  '-in' => $rs->get_column('artist')->as_query
                 }
    );

    while(my $row = $ar_rs->next){
        print "sub query: ".$row->name."\n";

    }
    

对应的 SQL ：

    SELECT * from artist where artistid in ( select artist from cd where
    artist = 5 or artist = 6);
    

同样还有 where 语句的条件的嵌套:

    my @albums = $schema->resultset('Album')->search({
      -or => [
        -and => [
          artist => { 'like', '%Smashing Pumpkins%' },
          title  => 'Siamese Dream',
        ],
        artist => 'Starchildren',
      ],
    });

## join

join 语句,这个用的频率不是很高,使用 join 可以预先在 schema 文件里面定义 join 的关系,比如 Cd.pm:

    __PACKAGE__->belongs_to('artist' => 'MyDatabase::Main::Result::Artist');
    __PACKAGE__->has_many('tracks' => 'MyDatabase::Main::Result::Track');

然后我们来写 sql：

    my $rs = $schema->resultset('Cd')->search(
      {
        'artist.name' => 'Michael Jackson'
      },
      {
        join    => 'artist', # join the artist table
        order_by => 'artist.name'
      }
    );
    while(my $row = $rs->next){
      print "test_join row cdid is :".$row->cdid."\n";
    }

从上面的例子可以看到, join 的关联条件我们并不需要先写出来,因为在是 schema 我们已经通过has\_many定义好了关联, 而实际等同的 sql 就是:

    SELECT COUNT( * ) FROM cd me
    JOIN artist artist ON
    artist.artistid = me.artist
    WHERE ( artist.name = ? ): 'Michael Jackson'
    

其他的 left join ,操作同理,这里就不再獒述.

## update insert

`update`操作需要结合`search`,例如:

    my $up = $schema->resultset('Cd')->search(
      {'cdid' => 5}
    )->update({'title' => 'duncan'});
    

`search`里面定义`update`的条件,如果不写`search`就默认`update`所有行.
对应的 SQL ：

    UPDATE cd SET title = 'duncan' WHERE ( cdid = '5' )

`insert`语句的调用`create`语句来实现:

    my $rs = $schema->resultset('Cd')->find_or_create(
      {
        'cdid' =>7,
        'artist'=>7,
        'title' => 'kobe'
      }
    );

对应的 SQL：

    INSERT INTO cd ( artist, cdid, title) VALUES ( '7', '7', 'kobe' )

`create`和`find_or_create`的区别是find\_or\_create会检测是否有重复的行. 另外如果2个表定义了关联关系,可以一次插入多个表：

    $artist_rs->create(
       { artistid => 4, name => 'Manufactured Crap', cds => [
          { title => 'My First CD', year => 2006 },
          { title => 'Yet More Tweeny-Pop crap', year => 2007 },
        ],
       },
    );

更为强大的是`populate`,支持批量插入数据：

       $Arstist_rs->populate([
         [qw/artistid name/],
         [100, 'A Formally Unknown Singer'],
         [101, 'A singer that jumped the shark two albums ago'],
         [102, 'An actually cool singer'],
       ]);
    



## transaction

事务操作,在支持事务的数据库里面,我们需要 txt\_do 提交和回滚的操作:

    my $genus = $schema->resultset('Cd')->find(2);
    my $coderef2 = sub {
      $genus->extinct(1);
      $genus->update;
    };
    my $coderef1 = sub {
      $genus->add_to_species({ title => 'Bad' });
      $genus->wings(2);
      $genus->update;
      $schema->txn_do($coderef2);
      # Can have a nested transaction. Only the outer will actualy commit
      return $genus->species;
    };

       use Try::Tiny;
       my $rs;
       try {
         $rs = $schema->txn_do($coderef1);
       } catch {
         # Transaction failed
         die "the sky is falling!"           #
           if ($_ =~ /Rollback failed/);     # Rollback failed
         deal_with_failed_transaction();
       };
    

## limit rows

如何指定返回行数,例如:

    SELECT me.cdid, me.artist, me.title FROM cd me WHERE ( cdid > '1' ) LIMIT 3

该操作限制返回3行,对于 DBIx 如何实现:

    sub {
      my $r = $schema->resultset('Cd')->search(
        {
          cdid => { '>'=> 1}
        },
        {
          rows => 3,
        }
      );
      $r->next;
    }->();

他同时还支持分页查询:

    my $rs = $schema->resultset('Artist')->search(
      undef,
      {
        page => 1,  # page to return (defaults to 1)
        rows => 10, # number of results per page
      },
    );
    return $rs->all(); # all records for page 1
    return $rs->page(2); # records for page 2

指定单行操作:

    sub {
      my $rs = $schema->resultset('Cd')->search(
        undef,
        {
          order_by => 'cdid',
          rows => 1,
        }
      )->single;
    }->();
    

这里如果不指定 rows => 1 将会抛出一个异常.

## 多表关联

指定表之间的关联关系可以减少很多代码,不需要每一个 sql 都写关联查询,而是直接调用`search_related`,例如:

    package My::User;
    use base 'DBIx::Class::Core';

    __PACKAGE__->table('user');
    __PACKAGE__->add_columns(qw/id name/);
    __PACKAGE__->set_primary_key('id');
    __PACKAGE__->has_many('user_address' => 'My::UserAddress', 'user');
    __PACKAGE__->many_to_many('addresses' => 'user_address', 'address');

    package My::UserAddress;
    use base 'DBIx::Class::Core';
    __PACKAGE__->table('user_address');
    __PACKAGE__->add_columns(qw/user address/);
    __PACKAGE__->set_primary_key(qw/user address/);
    __PACKAGE__->belongs_to('user' => 'My::User');

    __PACKAGE__->belongs_to('address' => 'My::Address');
    package My::Address;

    use base 'DBIx::Class::Core';
    __PACKAGE__->table('address');
    __PACKAGE__->add_columns(qw/id street town area_code country/);

    __PACKAGE__->set_primary_key('id');
    __PACKAGE__->has_many('user_address' => 'My::UserAddress', 'address');

    __PACKAGE__->many_to_many('users' => 'user_address', 'user');
    $rs = $user->addresses(); # get all addresses for a user

       $rs = $address->users(); # get all users for an address
       my $address = $user->add_to_addresses(    # returns a My::Address instance,
         {
           country => 'United Kingdom',
           area_code => 'XYZ',
           town => 'London',
           street => 'Sesame',
         }
       );
    



## set quote

`DBIx::Class`中的`quote`方法

    $schema->storage->sql_maker->quote_char([ qw/[ ]/] );
    $schema->storage->sql_maker->name_sep('.');

你可以在`connect`的时候就指定:

    my $schema = My::Schema->connect(
     'dbi:mysql:my_db',
     'db_user',
     'db_password',
     {
       quote_char => '"',
       name_sep   => '.'
     }
    )
    

# extension function     

对于一些经常用到的方法,你可以封装到`ResultSet`里面,使用的时候直接调用方法就可以了:

    package MyDatabase::Main::ResultSet::Cd;

    use strict;
    use warnings;
    use base 'DBIx::Class::ResultSet';

    sub search_cds_ordered {
        my ($self) = @_;

      return $self->search(
          {},
          { order_by => 'title DESC' },

        );
    }
    1;
    

使用的时候:
    

    my $rs = $schema->resultset('Cd')->search_cds_ordered;



# char unicode

指定数据库字符集 MYSQL:

    my $schema = My::Schema->connection('dbi:mysql:dbname=test',
                           $user, $pass,
                            { mysql_enable_utf8 => 1} );

pgsql:

    my $schema = My::Schema->connection('dbi:Pg:dbname=test',
                            $user, $pass,
                            { pg_enable_utf8 => 1} );

    

# cache

使用`cache`

    my $resultset = $schema->resultset('Artist')->search( undef, { cache => 1 } );
    while( my $artist = $resultset->next ) {
      ... do stuff ...
    }
    $rs->first; # without cache, this would issue a query
    

如果没有缓存,这里`first`也就返回不了.

DBIx 的从`cache`实现是基于`DBI`的`prepare_cahed`,但是如果每个 sql 都缓存,数量一大就会造成内存不够,如果发生了这个情况,
使用下面的方法来释放缓存

    # print all currently cached prepared statements
    print for keys %{$schema->storage->dbh->{CachedKids}};

    # get a count of currently cached prepared statements
    my $count = scalar keys %{$schema->storage->dbh->{CachedKids}};

如果一切正常的话,下面你就可以clear cache了

    my $kids = $schema->storage->dbh->{CachedKids};
    delete @{$kids}{keys %$kids} if scalar keys %$kids > 100;



# trace and debug

是使用 dbix debug 的时候需要指定 :

    MyDatabase::MyDatabase->storage()->debug(1);

你可以写自己的 profile 来指定 debug 怎么输出:

    package Profiler;
    use strict;
    use base 'DBIx::Class::Storage::Statistics';

    use Time::HiRes qw(time);
    my $start;
    sub query_start {
      my $self = shift();
      my $sql = shift();
      my @params = @_;
      map{ $sql =~ s/\?/$_/ } @params;
      $self->print("Executing $sql \n");
      $start = time();
    }

    sub query_end {
      my $self = shift();

      my $sql = shift();
      my @params = @_;
      printf("Execution took %0.4f seconds.\n", time() - $start);
      $start = undef;
    }
    1;
    

然后要载入哥刚写好的 profile

    my $obj = new Profiler;
    #MyDatabase::Main->storage()->debugobj( $obj );
    #MyDatabase::MyDatabase->storage()->debug(1);
    my $schema = MyDatabase::Main->connect(
        $dsn,
        $user,
        $pass
    );
    use Data::Dumper;
    use IO::File;
    $schema->storage->debugobj($obj);
    $schema->storage->debug(1);

调试的时候就能看到 sql 语句执行情况了.



# SQL literal

最后,如果你实在不习惯这些土逼的数据结构来写 sql 的操作,`DBIx::Class`还提供了通俗的sql接口:

    package My::Schema::Result::UserFriendsComplex;
    use strict;

    use warnings;
    use base qw/DBIx::Class::Core/;
    __PACKAGE__->table_class('DBIx::Class::ResultSource::View');

    # ->table, ->add_columns, etc.
    # do not attempt to deploy() this view
    __PACKAGE__->result_source_instance->is_virtual(1);

    __PACKAGE__->result_source_instance->view_definition(
        qq{ SELECT u.* FROM user u INNER JOIN user_friends f ON u.id = f.user_id
        WHERE f.friend_user_id = ?}   
    );
    

    #bind value
    my $friends = $schema->resultset( 'UserFriendsComplex' )->search( {},
      {
        bind  => [ 12345, 12345 ]
      }
    );

近来想整理之前的文档，发现好多纰漏，自以为还是太懒了，好多事可以做一直都没有完成，珍惜时间把。
新整理的`DBIx::Class`调整了一下排版，之前的 pod 也丢了，又重新扒了一遍，将就看下把, 如果代码有不
能跑的，mail `yiming.jin@live.com`，我抽时间fix.

# 作者

舌尖上的牛氓 


