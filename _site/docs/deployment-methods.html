<!DOCTYPE HTML>
<html lang="en-US">
<head>
  <meta charset="UTF-8">
  <title>dbic cookbook</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="alternate" type="application/rss+xml" title="Jekyll • Simple, blog-aware, static sites - Feed" href="/feed.xml" />
  <link rel="alternate" type="application/atom+xml" title="Recent commits to Jekyll’s master branch" href="https://github.com/mojombo/jekyll/commits/master.atom" />
  <link href='http://fonts.googleapis.com/css?family=Lato:100,300,400,700,900,100italic,300italic,400italic,700italic,900italic' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Arizonia' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/normalize.css" />
  <link rel="stylesheet" href="/css/gridism.css" />
  <link rel="stylesheet" href="/css/style.css" />
  <link rel="stylesheet" href="/css/pygments.css" />
  <link rel="stylesheet" href="/css/duoshuo.css" />

  <link rel="icon" type="image/x-icon" href="/favicon.png" />
  <script src="/js/modernizr-2.5.3.min.js"></script>
</script>
</head>


<body class="wrap">
  <header>
  <nav class="mobile-nav show-on-mobiles">
    <ul>
  <li class="">
    <a href="/">Overview</a>
  </li>
  <li class="current">
    <a href="/docs/home/">Doc<span class="show-on-mobiles">s</span><span class="hide-on-mobiles">umentation</span></a>
  </li>
  <li class="current">
    <a href="/news/">Blog</a>
  </li>
<!--  <li class="current">
    <a href="/news/">News</a>
  </li>
  <li class="">
    <a href="https://github.com/mojombo/jekyll"><span class="hide-on-mobiles">View on </span>GitHub</a>
</li>
-->
</ul>

  </nav>
  <div class="grid">
    <div class="unit one-third center-on-mobiles">
      <h1>
        <a href="/">
          <span>舌尖上的牛氓</span>
          <img src="/img/zh.gif" width="620" height="64" alt="">
        </a>
      </h1>
    </div>
    <nav class="main-nav unit two-thirds hide-on-mobiles">
      <ul>
  <li class="">
    <a href="/">Overview</a>
  </li>
  <li class="current">
    <a href="/docs/home/">Doc<span class="show-on-mobiles">s</span><span class="hide-on-mobiles">umentation</span></a>
  </li>
  <li class="current">
    <a href="/news/">Blog</a>
  </li>
<!--  <li class="current">
    <a href="/news/">News</a>
  </li>
  <li class="">
    <a href="https://github.com/mojombo/jekyll"><span class="hide-on-mobiles">View on </span>GitHub</a>
</li>
-->
</ul>

    </nav>
  </div>
</header>

    <section class="news">
    <div class="grid">

      <div class="docs-nav-mobile unit whole show-on-mobiles">
  <select onchange="if (this.value) window.location.href=this.value">
    <option value="">Navigate the blog…</option>
    <option value="/news/">Home</option>
    <optgroup label="v1.x">
      
    </optgroup>
  </select>
</div>


      <div class="unit four-fifths">
    
        <article>
  <h2>
    dbic cookbook
    <a href="/docs/deployment-methods.html" class="permalink" title="Permalink">∞</a>
  </h2>
  <span class="post-category">
    
    <span class="label">release</span>
    
  </span>
  <div class="post-meta">
    <span class="post-date">
      06 Sep 2013
    </span>
    <a href="https://github.com/舌尖上的牛氓" class="post-author">
      <img src="https://github.com/舌尖上的牛氓.png" class="avatar" />
      舌尖上的牛氓
    </a>
  </div>
  <p class="post-content">
    
<h1 id="_dbixclass">什么是 DBIx::Class</h1>

<p><code>DBIx::Class</code> 是一个perl5的面向对象的数据库 <code>api</code> ,相比传统的 <code>DBI</code>, <code>DBIx::Class</code> 提供了更为强大的功能和更灵活,更好扩展的特性,可能有些人觉得<code>oop</code>的perl编程相比原来的传统<code>DBI</code>速度上并 没有什么优势,但是实际上数据库操作的瓶颈真正在于数据库的优化,表的优化,<code>SQL</code>的优化, 而应用程序的影响在当今的条件下已经可以忽略不计.</p>

<h1 id="">概要</h1>

<p><code>DBIx::Class</code>可以分为几大部分: <code>Schema</code> , <code>Result</code> , <code>ResultSource</code> , <code>Storage</code> , <code>ResultSet</code></p>

<p><code>schema-DBIx::Class::Schema</code> 这个类主要用来导入一个库的 schema.</p>

<p><code>Result-DBIx::Class::Result</code> 主要设置数据库表的属性,一般是一个表一个 pm文件,类似配置文件的功能.</p>

<p><code>ResultSet-DBIx::Class::ResultSet</code> sql查询的类,可扩展</p>

<p><code>Storage-DBIx::Class::Storage</code> DBIx 的 storage.</p>

<h1 id="dbix_begin">DBIx begin</h1>

<p>下面就开始 DBIx 的操作了 以建立 artist,cd,track 3个表为例,要使用 DBIx ,我们首先配置每张表的 schema ,一个表的属性 就是一个 pm 包,以这个三个表为例.</p>

<h2 id="config_schema">config schema</h2>

<p>配置好 schema <code>MyDatabase::Main::Result::Artist</code> (#ps这里一般都不手写了，可以在db建好了，然后用脚本倒出来，还支持moose的哦)</p>

<pre><code>package MyDatabase::Main::Result::Artist;

use warnings;
use strict;
use base qw/DBIx::Class::Core/;

__PACKAGE__-&gt;table('artist'); 
__PACKAGE__-&gt;add_columns(qw/ artistid name /); #columns config

__PACKAGE__-&gt;set_primary_key('artistid');    # set pk
__PACKAGE__-&gt;has_many('cds' =&gt; 'MyDatabase::Main::Result::Cd'); #set relation

1;

package MyDatabase::Main::Result::Cd;
use warnings;
use strict;

use base qw/DBIx::Class::Core/;
__PACKAGE__-&gt;table('cd');
__PACKAGE__-&gt;add_columns(qw/ cdid artist title/);

__PACKAGE__-&gt;set_primary_key('cdid');
__PACKAGE__-&gt;belongs_to('artist' =&gt; 'MyDatabase::Main::Result::Artist');

__PACKAGE__-&gt;has_many('tracks' =&gt; 'MyDatabase::Main::Result::Track');
1;

package MyDatabase::Main::Result::Track;

use warnings;
use strict;
use base qw/DBIx::Class::Core/;

__PACKAGE__-&gt;table('track');
__PACKAGE__-&gt;add_columns(qw/ trackid cd title/);
__PACKAGE__-&gt;set_primary_key('trackid');

__PACKAGE__-&gt;belongs_to('cd' =&gt; 'MyDatabase::Main::Result::Cd');

1;</code></pre>

<p>然后我们需要导入这些表的 schema 的 namespace : Main.pm 然后开始创建表:</p>

<pre><code>package MyDatabase::Main;
use base qw/DBIx::Class::Schema/;

__PACKAGE__-&gt;load_namespaces;
1;

CREATE TABLE artist (
  artistid INTEGER PRIMARY KEY,
  name TEXT NOT NULL 
);

CREATE TABLE cd (
  cdid INTEGER PRIMARY KEY,
  artist INTEGER NOT NULL REFERENCES artist(artistid),
  title TEXT NOT NULL

);
CREATE TABLE track (
  trackid INTEGER PRIMARY KEY,
  cd INTEGER NOT NULL REFERENCES cd(cdid),
  title TEXT NOT NULL

);</code></pre>

<p>最后我们需要往表里插入数据,这里只作为测试,就不说明代码了:</p>

<pre><code>#!/usr/bin/env perl
use strict;

use warnings;
use MyDatabase::Main;
my $database = &quot;dbix&quot;;

my $hostname = 'localhost';
my $port = 3306;

my $dsn = &quot;DBI:mysql:database=$database;host=$hostname;port=$port&quot;;
my $user = 'root';
my $pass = 'root';
my $schema = MyDatabase::Main-&gt;connect( $dsn );

#  here's some of the sql that is going to be generated by the schema
#  INSERT INTO artist VALUES (NULL,'Michael Jackson');
#  INSERT INTO artist VALUES (NULL,'Eminem');
my @artists = (['Michael Jackson'], ['Eminem']);

$schema-&gt;populate('Artist', [
    [qw/name/],
    @artists,
]);
my %albums = (
    'Thriller' =&gt; 'Michael Jackson',
    'Bad' =&gt; 'Michael Jackson',
    'The Marshall Mathers LP' =&gt; 'Eminem',
);

my @cds;
foreach my $lp (keys %albums) {
    my $artist = $schema-&gt;resultset('Artist')-&gt;find({
        name =&gt; $albums{$lp}
    });
    push @cds, [$lp, $artist-&gt;id];
}
$schema-&gt;populate('Cd', [
    [qw/title artist/],
    @cds,
]);
my %tracks = (
    'Beat It'         =&gt; 'Thriller',
    'Billie Jean'     =&gt; 'Thriller',
    'Dirty Diana'     =&gt; 'Bad',
    'Smooth Criminal' =&gt; 'Bad',
    'Leave Me Alone'  =&gt; 'Bad',
    'Stan'            =&gt; 'The Marshall Mathers LP',
    'The Way I Am'    =&gt; 'The Marshall Mathers LP',
);
my @tracks;

foreach my $track (keys %tracks) {
    my $cd = $schema-&gt;resultset('Cd')-&gt;find({
        title =&gt; $tracks{$track},
    });
    push @tracks, [$cd-&gt;id, $track];
}
$schema-&gt;populate('Track',[
    [qw/cd title/],
    @tracks,
]);</code></pre>

<p>ok,现在有了可以操作的数据库和表了</p>

<h2 id="connect_database">connect database</h2>

<p>接下来就是连接数据库,不同的数据库连接方式大同小异,不同的只是 dbi_dsn 部分,<code>\%dbi_params</code> 可以设置一些属性例如 { AutoCommit =&gt; 1,…}</p>

<pre><code>#DBI:mysql:database=$database;host=$hostname;port=$port
my $schema = MyApp::Schema-&gt;connect($dbi_dsn, $user, $pass, \%dbi_params);

#pgsql
my $schema = DB::Schema-&gt;connection('dbi:Pg:dbname=test');

#DBI:mysql:database=$database;host=$hostname;port=$port</code></pre>

<h1 id="sql">SQL</h1>

<p>sql 是 dbi 最常要做的,<code>DBIx::Class</code>采用了很多关键字来实现 sql ,所有的 sql 操作都通过这些 关键字来实现,下面是一些例子:</p>

<pre><code>my $johns_rs = $schema-&gt;resultset('Artist')-&gt;search(
  # Build your WHERE using an SQL::Abstract structure:
  { name =&gt; { like =&gt; 'John%' } }
);
# Execute a joined query to get the cds.
my @all_john_cds = $johns_rs-&gt;search_related('cds')-&gt;all;

 #real SQL:
 # select * from 
 # artist 
 # where  name like 'John%'</code></pre>

<h2 id="keyword__not_likeor">keyword ( not, like,!=,=,&gt;,&lt;,or)</h2>

<p>DBIx 的 sql 查询分为2部分,首先导入表对象,也就是</p>

<pre><code>$schema-&gt;resultset('Cd')#Cd对应之前设置的pm包的名字,注意不是表名,如果填表名
#这里会抛出一个异常</code></pre>

<p>然后就是 search 了, search 就类似<code>DBI</code>里面的<code>prepare</code></p>

<pre><code>$schema-&gt;resultset('Cd')-&gt;search(
    {}, #这里配置where条件里的sql语句
    {}  #这里配置h后面的修饰的语句和select部分,
)</code></pre>

<p>看下面的例子:</p>

<pre><code>sub test_sql_select_where_basic{
  my $rs = $schema-&gt;resultset('Cd')-&gt;search(
    {
        'cdid'  =&gt; [1,3],
        'title' =&gt; 'Bad',
        'title' =&gt; {'like','%Bad%'},
        'cdid'  =&gt; 3,
        'artist'=&gt; {'between'=&gt;[1,3]},
        'cdid'  =&gt; { '&gt;'=&gt;2},
    },
  );
  $rs-&gt;next;
}</code></pre>

<p>上面的例子涵盖了not,like等的用法,基本的原则就是在一个{}里面,定义where条件,对于多个值的区域采取[]引用, 是所有条件的运算符紧在在字段后面的hash引用里面. 对应输出的SQL：</p>

<pre><code>   SELECT me.cdid, me.artist, me.title
   FROM cd me
   WHERE
   (
       (
           ( artist BETWEEN '1' AND '3' )
           AND
           cdid &gt; '2'
           AND
           title LIKE '%Bad%'
       )
   )</code></pre>

<h2 id="group_by">group by</h2>

<p>groupby 的例子：</p>

<pre><code> my $rs = $schema-&gt;resultset('Cd')-&gt;search(
   {
   },
   {
     group_by  =&gt; 'cdid',
   }
 );
 $rs-&gt;next;</code></pre>

<h2 id="order_by">order by</h2>

<p>oderby 例子：</p>

<pre><code>my $rs = $schema-&gt;resultset('Cd')-&gt;search(
  {
      'cdid'  =&gt; [1,3],
      'title' =&gt; 'Bad',
      'title' =&gt; {'like','%Bad%'},
      'cdid'  =&gt; 3,
      'artist'=&gt; {'between'=&gt;[1,3]},
      'cdid'  =&gt; { '&gt;'=&gt;2},
      'cdid'  =&gt; {'in' =&gt; [1,3]}
  },
  {
    order_by  =&gt; 'cdid',
  }
);

$rs-&gt;next;

 __DATA__
 SQL:
    SELECT me.cdid, me.artist, me.title FROM cd me
    WHERE ( ( ( artist BETWEEN '1' AND '3' ) AND cdid &gt; '2' AND title LIKE '%Bad%' ) )
    ORDER BY cdid</code></pre>

<h2 id="asalias">as,alias</h2>

<p>有的时候 sql 需要定义别名,<code>DBIx</code>的做法是:</p>

<pre><code>$rs = $schema-&gt;resultset('Cd')-&gt;search(
  {},
  {
    'select' =&gt; ['title',{LENGTH =&gt; 'cdid'}],
    'as' =&gt; ['tit','len_cd'],
  }
);

my $cd = $rs-&gt;next;
my $name_length = $cd-&gt;get_column('tit');

print &quot;name lenth is $name_length\n&quot;;</code></pre>

<p><code>select</code> : 确定选定的列表</p>

<p><code>as</code> : 后面的列表为对应的select的列表里面字段的别名</p>

<p><code>LENGTH</code> : 数据库的函数,通常我们要获取别名的数据,是通过get_column来获取,但是也可以实现在schema文件里面配置好.</p>

<h2 id="sumaveragemanmin">sum,average,man,min</h2>

<p>使用数据库的函数</p>

<pre><code>$rs = $schema-&gt;resultset('Cd')-&gt;search(
  {},
  {
    'select' =&gt; [
      {'max' =&gt; 'title'},
      {'sum' =&gt; 'cdid'},
    ],
    'as' =&gt; ['max_title','sum_cd'],
    'group_by' =&gt; 'cdid',
  }
);
my $cd = $rs-&gt;next;

my $name_length = $cd-&gt;get_column('max_title');
my $sum_title = $cd-&gt;get_column('sum_cd');

#equal SQL:
#SELECT MAX( title ), SUM( cdid ) FROM cd me GROUP BY cdid</code></pre>

<p>另外一种方法就是 oo 风格</p>

<pre><code>my $rs = $schema-&gt;resultset('Cd')-&gt;search(
    undef,
    {
        columns =&gt;  ['cdid','title'],
    }
);
my $count = $rs-&gt;count;</code></pre>

<h2 id="sub_query">sub query</h2>

<p>sql 子查询经常会用到,<code>DBIx</code>同样可以实现,看下面的例子:</p>

<pre><code>my $rs = $schema-&gt;resultset('Cd')-&gt;search(
    {
        artist =&gt; [qw/5 6/],
    }
);#sub query

my $ar_rs = $schema-&gt;resultset('Artist')-&gt;search(
    'artistid' =&gt; {
              '-in' =&gt; $rs-&gt;get_column('artist')-&gt;as_query
             }
);

while(my $row = $ar_rs-&gt;next){
    print &quot;sub query: &quot;.$row-&gt;name.&quot;\n&quot;;

}</code></pre>

<p>对应的 SQL ：</p>

<pre><code>SELECT * from artist where artistid in ( select artist from cd where
artist = 5 or artist = 6);</code></pre>

<p>同样还有 where 语句的条件的嵌套:</p>

<pre><code>my @albums = $schema-&gt;resultset('Album')-&gt;search({
  -or =&gt; [
    -and =&gt; [
      artist =&gt; { 'like', '%Smashing Pumpkins%' },
      title  =&gt; 'Siamese Dream',
    ],
    artist =&gt; 'Starchildren',
  ],
});</code></pre>

<h2 id="join">join</h2>

<p>join 语句,这个用的频率不是很高,使用 join 可以预先在 schema 文件里面定义 join 的关系,比如 Cd.pm:</p>

<pre><code>__PACKAGE__-&gt;belongs_to('artist' =&gt; 'MyDatabase::Main::Result::Artist');
__PACKAGE__-&gt;has_many('tracks' =&gt; 'MyDatabase::Main::Result::Track');</code></pre>

<p>然后我们来写 sql：</p>

<pre><code>my $rs = $schema-&gt;resultset('Cd')-&gt;search(
  {
    'artist.name' =&gt; 'Michael Jackson'
  },
  {
    join    =&gt; 'artist', # join the artist table
    order_by =&gt; 'artist.name'
  }
);
while(my $row = $rs-&gt;next){
  print &quot;test_join row cdid is :&quot;.$row-&gt;cdid.&quot;\n&quot;;
}</code></pre>

<p>从上面的例子可以看到, join 的关联条件我们并不需要先写出来,因为在是 schema 我们已经通过has_many定义好了关联, 而实际等同的 sql 就是:</p>

<pre><code>SELECT COUNT( * ) FROM cd me
JOIN artist artist ON
artist.artistid = me.artist
WHERE ( artist.name = ? ): 'Michael Jackson'</code></pre>

<p>其他的 left join ,操作同理,这里就不再獒述.</p>

<h2 id="update_insert">update insert</h2>

<p><code>update</code>操作需要结合<code>search</code>,例如:</p>

<pre><code>my $up = $schema-&gt;resultset('Cd')-&gt;search(
  {'cdid' =&gt; 5}
)-&gt;update({'title' =&gt; 'duncan'});</code></pre>

<p><code>search</code>里面定义<code>update</code>的条件,如果不写<code>search</code>就默认<code>update</code>所有行. 对应的 SQL ：</p>

<pre><code>UPDATE cd SET title = 'duncan' WHERE ( cdid = '5' )</code></pre>

<p><code>insert</code>语句的调用<code>create</code>语句来实现:</p>

<pre><code>my $rs = $schema-&gt;resultset('Cd')-&gt;find_or_create(
  {
    'cdid' =&gt;7,
    'artist'=&gt;7,
    'title' =&gt; 'kobe'
  }
);</code></pre>

<p>对应的 SQL：</p>

<pre><code>INSERT INTO cd ( artist, cdid, title) VALUES ( '7', '7', 'kobe' )</code></pre>

<p><code>create</code>和<code>find_or_create</code>的区别是find_or_create会检测是否有重复的行. 另外如果2个表定义了关联关系,可以一次插入多个表：</p>

<pre><code>$artist_rs-&gt;create(
   { artistid =&gt; 4, name =&gt; 'Manufactured Crap', cds =&gt; [
      { title =&gt; 'My First CD', year =&gt; 2006 },
      { title =&gt; 'Yet More Tweeny-Pop crap', year =&gt; 2007 },
    ],
   },
);</code></pre>

<p>更为强大的是<code>populate</code>,支持批量插入数据：</p>

<pre><code>   $Arstist_rs-&gt;populate([
     [qw/artistid name/],
     [100, 'A Formally Unknown Singer'],
     [101, 'A singer that jumped the shark two albums ago'],
     [102, 'An actually cool singer'],
   ]);</code></pre>

<h2 id="transaction">transaction</h2>

<p>事务操作,在支持事务的数据库里面,我们需要 txt_do 提交和回滚的操作:</p>

<pre><code>my $genus = $schema-&gt;resultset('Cd')-&gt;find(2);
my $coderef2 = sub {
  $genus-&gt;extinct(1);
  $genus-&gt;update;
};
my $coderef1 = sub {
  $genus-&gt;add_to_species({ title =&gt; 'Bad' });
  $genus-&gt;wings(2);
  $genus-&gt;update;
  $schema-&gt;txn_do($coderef2);
  # Can have a nested transaction. Only the outer will actualy commit
  return $genus-&gt;species;
};

   use Try::Tiny;
   my $rs;
   try {
     $rs = $schema-&gt;txn_do($coderef1);
   } catch {
     # Transaction failed
     die &quot;the sky is falling!&quot;           #
       if ($_ =~ /Rollback failed/);     # Rollback failed
     deal_with_failed_transaction();
   };</code></pre>

<h2 id="limit_rows">limit rows</h2>

<p>如何指定返回行数,例如:</p>

<pre><code>SELECT me.cdid, me.artist, me.title FROM cd me WHERE ( cdid &gt; '1' ) LIMIT 3</code></pre>

<p>该操作限制返回3行,对于 DBIx 如何实现:</p>

<pre><code>sub {
  my $r = $schema-&gt;resultset('Cd')-&gt;search(
    {
      cdid =&gt; { '&gt;'=&gt; 1}
    },
    {
      rows =&gt; 3,
    }
  );
  $r-&gt;next;
}-&gt;();</code></pre>

<p>他同时还支持分页查询:</p>

<pre><code>my $rs = $schema-&gt;resultset('Artist')-&gt;search(
  undef,
  {
    page =&gt; 1,  # page to return (defaults to 1)
    rows =&gt; 10, # number of results per page
  },
);
return $rs-&gt;all(); # all records for page 1
return $rs-&gt;page(2); # records for page 2</code></pre>

<p>指定单行操作:</p>

<pre><code>sub {
  my $rs = $schema-&gt;resultset('Cd')-&gt;search(
    undef,
    {
      order_by =&gt; 'cdid',
      rows =&gt; 1,
    }
  )-&gt;single;
}-&gt;();</code></pre>

<p>这里如果不指定 rows =&gt; 1 将会抛出一个异常.</p>

<h2 id="_2">多表关联</h2>

<p>指定表之间的关联关系可以减少很多代码,不需要每一个 sql 都写关联查询,而是直接调用<code>search_related</code>,例如:</p>

<pre><code>package My::User;
use base 'DBIx::Class::Core';

__PACKAGE__-&gt;table('user');
__PACKAGE__-&gt;add_columns(qw/id name/);
__PACKAGE__-&gt;set_primary_key('id');
__PACKAGE__-&gt;has_many('user_address' =&gt; 'My::UserAddress', 'user');
__PACKAGE__-&gt;many_to_many('addresses' =&gt; 'user_address', 'address');

package My::UserAddress;
use base 'DBIx::Class::Core';
__PACKAGE__-&gt;table('user_address');
__PACKAGE__-&gt;add_columns(qw/user address/);
__PACKAGE__-&gt;set_primary_key(qw/user address/);
__PACKAGE__-&gt;belongs_to('user' =&gt; 'My::User');

__PACKAGE__-&gt;belongs_to('address' =&gt; 'My::Address');
package My::Address;

use base 'DBIx::Class::Core';
__PACKAGE__-&gt;table('address');
__PACKAGE__-&gt;add_columns(qw/id street town area_code country/);

__PACKAGE__-&gt;set_primary_key('id');
__PACKAGE__-&gt;has_many('user_address' =&gt; 'My::UserAddress', 'address');

__PACKAGE__-&gt;many_to_many('users' =&gt; 'user_address', 'user');
$rs = $user-&gt;addresses(); # get all addresses for a user

   $rs = $address-&gt;users(); # get all users for an address
   my $address = $user-&gt;add_to_addresses(    # returns a My::Address instance,
     {
       country =&gt; 'United Kingdom',
       area_code =&gt; 'XYZ',
       town =&gt; 'London',
       street =&gt; 'Sesame',
     }
   );</code></pre>

<h2 id="set_quote">set quote</h2>

<p><code>DBIx::Class</code>中的<code>quote</code>方法</p>

<pre><code>$schema-&gt;storage-&gt;sql_maker-&gt;quote_char([ qw/[ ]/] );
$schema-&gt;storage-&gt;sql_maker-&gt;name_sep('.');</code></pre>

<p>你可以在<code>connect</code>的时候就指定:</p>

<pre><code>my $schema = My::Schema-&gt;connect(
 'dbi:mysql:my_db',
 'db_user',
 'db_password',
 {
   quote_char =&gt; '&quot;',
   name_sep   =&gt; '.'
 }
)</code></pre>

<h1 id="extension_function">extension function</h1>

<p>对于一些经常用到的方法,你可以封装到<code>ResultSet</code>里面,使用的时候直接调用方法就可以了:</p>

<pre><code>package MyDatabase::Main::ResultSet::Cd;

use strict;
use warnings;
use base 'DBIx::Class::ResultSet';

sub search_cds_ordered {
    my ($self) = @_;

  return $self-&gt;search(
      {},
      { order_by =&gt; 'title DESC' },

    );
}
1;</code></pre>

<p>使用的时候:</p>

<pre><code>my $rs = $schema-&gt;resultset('Cd')-&gt;search_cds_ordered;</code></pre>

<h1 id="char_unicode">char unicode</h1>

<p>指定数据库字符集 MYSQL:</p>

<pre><code>my $schema = My::Schema-&gt;connection('dbi:mysql:dbname=test',
                       $user, $pass,
                        { mysql_enable_utf8 =&gt; 1} );</code></pre>

<p>pgsql:</p>

<pre><code>my $schema = My::Schema-&gt;connection('dbi:Pg:dbname=test',
                        $user, $pass,
                        { pg_enable_utf8 =&gt; 1} );</code></pre>

<h1 id="cache">cache</h1>

<p>使用<code>cache</code></p>

<pre><code>my $resultset = $schema-&gt;resultset('Artist')-&gt;search( undef, { cache =&gt; 1 } );
while( my $artist = $resultset-&gt;next ) {
  ... do stuff ...
}
$rs-&gt;first; # without cache, this would issue a query</code></pre>

<p>如果没有缓存,这里<code>first</code>也就返回不了.</p>

<p>DBIx 的从<code>cache</code>实现是基于<code>DBI</code>的<code>prepare_cahed</code>,但是如果每个 sql 都缓存,数量一大就会造成内存不够,如果发生了这个情况, 使用下面的方法来释放缓存</p>

<pre><code># print all currently cached prepared statements
print for keys %{$schema-&gt;storage-&gt;dbh-&gt;{CachedKids}};

# get a count of currently cached prepared statements
my $count = scalar keys %{$schema-&gt;storage-&gt;dbh-&gt;{CachedKids}};</code></pre>

<p>如果一切正常的话,下面你就可以clear cache了</p>

<pre><code>my $kids = $schema-&gt;storage-&gt;dbh-&gt;{CachedKids};
delete @{$kids}{keys %$kids} if scalar keys %$kids &gt; 100;</code></pre>

<h1 id="trace_and_debug">trace and debug</h1>

<p>是使用 dbix debug 的时候需要指定 :</p>

<pre><code>MyDatabase::MyDatabase-&gt;storage()-&gt;debug(1);</code></pre>

<p>你可以写自己的 profile 来指定 debug 怎么输出:</p>

<pre><code>package Profiler;
use strict;
use base 'DBIx::Class::Storage::Statistics';

use Time::HiRes qw(time);
my $start;
sub query_start {
  my $self = shift();
  my $sql = shift();
  my @params = @_;
  map{ $sql =~ s/\?/$_/ } @params;
  $self-&gt;print(&quot;Executing $sql \n&quot;);
  $start = time();
}

sub query_end {
  my $self = shift();

  my $sql = shift();
  my @params = @_;
  printf(&quot;Execution took %0.4f seconds.\n&quot;, time() - $start);
  $start = undef;
}
1;</code></pre>

<p>然后要载入哥刚写好的 profile</p>

<pre><code>my $obj = new Profiler;
#MyDatabase::Main-&gt;storage()-&gt;debugobj( $obj );
#MyDatabase::MyDatabase-&gt;storage()-&gt;debug(1);
my $schema = MyDatabase::Main-&gt;connect(
    $dsn,
    $user,
    $pass
);
use Data::Dumper;
use IO::File;
$schema-&gt;storage-&gt;debugobj($obj);
$schema-&gt;storage-&gt;debug(1);</code></pre>

<p>调试的时候就能看到 sql 语句执行情况了.</p>

<h1 id="sql_literal">SQL literal</h1>

<p>最后,如果你实在不习惯这些土逼的数据结构来写 sql 的操作,<code>DBIx::Class</code>还提供了通俗的sql接口:</p>

<pre><code>package My::Schema::Result::UserFriendsComplex;
use strict;

use warnings;
use base qw/DBIx::Class::Core/;
__PACKAGE__-&gt;table_class('DBIx::Class::ResultSource::View');

# -&gt;table, -&gt;add_columns, etc.
# do not attempt to deploy() this view
__PACKAGE__-&gt;result_source_instance-&gt;is_virtual(1);

__PACKAGE__-&gt;result_source_instance-&gt;view_definition(
    qq{ SELECT u.* FROM user u INNER JOIN user_friends f ON u.id = f.user_id
    WHERE f.friend_user_id = ?}   
);


#bind value
my $friends = $schema-&gt;resultset( 'UserFriendsComplex' )-&gt;search( {},
  {
    bind  =&gt; [ 12345, 12345 ]
  }
);</code></pre>

<p>近来想整理之前的文档，发现好多纰漏，自以为还是太懒了，好多事可以做一直都没有完成，珍惜时间把。 新整理的<code>DBIx::Class</code>调整了一下排版，之前的 pod 也丢了，又重新扒了一遍，将就看下把, 如果代码有不 能跑的，mail <code>yiming.jin@live.com</code>，我抽时间fix.</p>

<h1 id="_3">作者</h1>

<p>舌尖上的牛氓</p>

  </p>
</article>

    
      </div>
      <div class="unit one-fifth hide-on-mobiles">
  <aside>
<!--    <ul>
      <li class="">
        <a href="/news/">All News</a>
      </li>
      <li class="">
        <a href="/news/releases/">Jekyll Releases</a>
      </li>
    </ul>
    <h4>Recent Releases</h4>
    <ul>
      
      <li>
        <a href="/docs/history/">History »</a>
      </li>
  </ul>
  -->
  </aside>
</div>


      <div class="clear"></div>

    </div>
  </section>


  <footer>
  <div class="grid">
    <div class="unit one-third center-on-mobiles">
      <p>By <a href="http://tom.preston-werner.com">Tom Preston-Werner</a>, <a href="http://quaran.to/">Nick Quaranto</a>, and many more <a href="https://github.com/mojombo/jekyll/graphs/contributors">awesome&nbsp;contributors</a>.</p>
    </div>
    <div class="unit two-thirds align-right center-on-mobiles">
      <p>
        Proudly hosted by
        <a href="https://github.com">
          <img src="/img/footer-logo.png" alt="GitHub • Social coding">
        </a>
      </p>
    </div>
  </div>
</footer>

  
  <!-- Gauges (http://gaug.es/) -->
  <script type="text/javascript">
    var _gauges = _gauges || [];
    (function() {
      var t   = document.createElement('script');
      t.type  = 'text/javascript';
      t.async = true;
      t.id    = 'gauges-tracker';
      t.setAttribute('data-site-id', '503c5af6613f5d0f19000027');
      t.src = '//secure.gaug.es/track.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(t, s);
    })();
  </script>





</body>
</html>
